import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';
import { forwardRef, Inject, Injectable, Logger } from '@nestjs/common';
import { AskQuestionDto } from '../dto/ask-question.dto';
import { MongoDbDataService } from '../../mongo/mongo.service';
import { PineconeService } from '../../pinecone/pinecone.service';
import { GeminiService } from '../../gemini/gemini.service';
import { ChatsessionService } from '../../chatsession/chatsession.service';

@Injectable()
export class AskService {
  private readonly logger = new Logger(AskService.name);

  constructor(
    private readonly geminiService: GeminiService,
    private readonly pineconeService: PineconeService,
    // @Inject(forwardRef(() => MongoDbDataService))
    private readonly mongoDbDataService: MongoDbDataService,
    private readonly chatsessionService: ChatsessionService,
    // @Inject(CACHE_MANAGER) private cacheManager: Cache
  ) {}

  /**
   * X·ª≠ l√Ω c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng v·ªõi session management t·ª± ƒë·ªông
   * @param askQuestionDto DTO ch·ª©a c√¢u h·ªèi v√† th√¥ng tin session
   * @returns C√¢u tr·∫£ l·ªùi v√† th√¥ng tin session
   */
  async processQuestionWithSession(askQuestionDto: AskQuestionDto): Promise<{
    answer: string;
    sessionId: string;
    messageId: string;
  }> {
    const { question, sessionId, userId, anonymousId } = askQuestionDto;
    const startTime = Date.now();
    this.logger.log(
      `ü§ñ [${new Date().toISOString()}] Processing question with session: ${question}`,
    );

    try {
      // Input validation
      if (!question || question.trim().length === 0) {
        throw new Error('Question is empty or invalid');
      }

      const cleanQuestion = question.trim();
      this.logger.log(`üìã Cleaned question: "${cleanQuestion}"`);

      // X·ª≠ l√Ω c√¢u h·ªèi ƒë·ªÉ l·∫•y c√¢u tr·∫£ l·ªùi
      const answer = await this.processQuestion(askQuestionDto);

      // T·ª± ƒë·ªông qu·∫£n l√Ω session v√† l∆∞u messages
      const sessionResult = await this.chatsessionService.handleChat(
        cleanQuestion,
        answer,
        sessionId,
        userId,
        anonymousId,
      );

      const processingTime = Date.now() - startTime;
      this.logger.log(
        `‚úÖ [SUCCESS] Question processed with session in ${processingTime}ms`,
      );

      return {
        answer,
        sessionId: sessionResult.sessionId,
        messageId: sessionResult.messageId,
      };
    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.logger.error(
        `‚ùå [ERROR] Question processing failed after ${processingTime}ms:`,
        error.message,
      );

      // Fallback answer
      const fallbackAnswer = this.getFallbackAnswer(question);

      // V·∫´n t·∫°o session v√† l∆∞u fallback message
      try {
        const sessionResult = await this.chatsessionService.handleChat(
          question,
          fallbackAnswer,
          sessionId,
          userId,
          anonymousId,
        );

        return {
          answer: fallbackAnswer,
          sessionId: sessionResult.sessionId,
          messageId: sessionResult.messageId,
        };
      } catch (sessionError) {
        this.logger.error(
          '‚ùå Session management failed:',
          sessionError.message,
        );
        return {
          answer: fallbackAnswer,
          sessionId: sessionId || 'error',
          messageId: 'error',
        };
      }
    }
  }

  /**
   * X·ª≠ l√Ω c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng b·∫±ng MongoDB-first approach v·ªõi RAG enhancement
   * @param question C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns C√¢u tr·∫£ l·ªùi ƒë∆∞·ª£c t·∫°o b·ªüi Gemini d·ª±a tr√™n d·ªØ li·ªáu t·ª´ MongoDB v√† Vector DB
   */
  async processQuestion(askQuestionDto: AskQuestionDto): Promise<string> {
    const { question } = askQuestionDto;
    const startTime = Date.now();
    this.logger.log(
      `ü§ñ [${new Date().toISOString()}] Processing question: ${question}`,
    );

    try {
      // Input validation
      if (!question || question.trim().length === 0) {
        throw new Error('Question is empty or invalid');
      }

      const cleanQuestion = question.trim();
      this.logger.log(`üìã Cleaned question: "${cleanQuestion}"`);

      // B∆∞·ªõc 1: MongoDB Primary Search (Optimized)
      let context = '';
      const mongoSuccess = false;

      try {
        this.logger.log('üóÑÔ∏è [STEP 1] Searching MongoDB (Primary Source)...');
        // const mongoContext = await this.mongoDbDataService.getRealtimeContext(cleanQuestion);

        // if (mongoContext && mongoContext.length > 0) {
        //   context = mongoContext;
        //   mongoSuccess = true;
        //   this.logger.log(`‚úÖ MongoDB context found: ${mongoContext.length} chars`);
        // } else {
        //   this.logger.log('‚ö†Ô∏è No MongoDB context found');
        // }
      } catch (mongoError) {
        this.logger.error('‚ùå MongoDB search failed:', mongoError.message);
      }

      // B∆∞·ªõc 2: Vector Enhancement (Always try for better context)
      try {
        this.logger.log('üîç [STEP 2] Vector search for enhanced context...');
        const questionEmbedding =
          await this.geminiService.createEmbedding(cleanQuestion);
        const searchResults = await this.pineconeService.queryVectors(
          questionEmbedding,
          mongoSuccess ? 3 : 5,
        );

        if (searchResults && searchResults.length > 0) {
          const vectorContext = searchResults
            .filter((result) => result.metadata && result.metadata.text)
            .map((result, index) => {
              const metadata = result.metadata || {};
              const text = metadata.text || '';
              const source = metadata.source || 'vector-db';
              const score = result.score
                ? ` (${(result.score * 100).toFixed(1)}%)`
                : '';
              return `[${source}${score}] ${text}`;
            })
            .join('\n');

          if (mongoSuccess) {
            context = `${context}\n\n--- Th√¥ng tin b·ªï sung t·ª´ Vector DB ---\n${vectorContext}`;
            this.logger.log(
              `‚úÖ Enhanced MongoDB with ${searchResults.length} vector results`,
            );
          } else {
            context = vectorContext;
            this.logger.log(
              `‚úÖ Using ${searchResults.length} vector results as primary context`,
            );
          }
        } else {
          this.logger.log('‚ö†Ô∏è No vector results found');
        }
      } catch (vectorError) {
        this.logger.warn(`‚ö†Ô∏è Vector search failed: ${vectorError.message}`);
      }

      // Fallback if no context found
      if (!context || context.trim().length === 0) {
        this.logger.log(
          '‚ö†Ô∏è No context found from any source, using general information',
        );
        context =
          'Th√¥ng tin t·ªïng quan v·ªÅ ƒê·∫°i h·ªçc FPT: ƒë√†o t·∫°o c√¥ng ngh·ªá th√¥ng tin, kinh doanh, v·ªõi nhi·ªÅu c∆° s·ªü t·∫°i Vi·ªát Nam.';
      }

      this.logger.log(`üìÑ Final context: ${context.length} chars`);

      // B∆∞·ªõc 3: AI Answer Generation (Optimized)
      this.logger.log('üß† [STEP 3] Generating AI answer...');
      const answer = await this.geminiService.generateAnswer(
        context,
        cleanQuestion,
      );

      const processingTime = Date.now() - startTime;
      this.logger.log(`‚úÖ [SUCCESS] Question processed in ${processingTime}ms`);

      return answer;
    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.logger.error(
        `‚ùå [ERROR] Question processing failed after ${processingTime}ms:`,
        error.message,
      );

      // Enhanced fallback with error context
      this.logger.log('üîÑ Using enhanced static fallback...');
      return this.getFallbackAnswer(question);
    }
  }

  /**
   * L·∫•y ng·ªØ c·∫£nh realtime t·ª´ MongoDB d·ª±a tr√™n t·ª´ kh√≥a trong c√¢u h·ªèi
   * DEPRECATED: Moved to MongoDbDataService.getRealtimeContext()
   * @param question C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns Ng·ªØ c·∫£nh t·ª´ MongoDB ho·∫∑c null
   */
  private async getRealtimeMongoContext_DEPRECATED(
    question: string,
  ): Promise<string | null> {
    try {
      const lowerQuestion = question.toLowerCase();
      const contextParts: string[] = [];

      this.logger.log(
        `üîç Analyzing question for MongoDB context: "${lowerQuestion}"`,
      );

      // T√¨m ki·∫øm campus
      if (
        lowerQuestion.includes('campus') ||
        lowerQuestion.includes('c∆° s·ªü') ||
        lowerQuestion.includes('ƒë·ªãa ch·ªâ')
      ) {
        this.logger.log('üè´ Searching for campus information...');
        const stats = await this.mongoDbDataService.getDataStatistics();
        if (stats.campuses > 0) {
          // T√¨m campus c·ª• th·ªÉ n·∫øu c√≥
          const campusKeywords = [
            'h√† n·ªôi',
            'hcm',
            'ƒë√† n·∫µng',
            'c·∫ßn th∆°',
            'quy nhon',
          ];
          for (const keyword of campusKeywords) {
            if (lowerQuestion.includes(keyword)) {
              const campus =
                await this.mongoDbDataService.getCampusByName(keyword);
              if (campus) {
                contextParts.push(
                  `Campus ${campus.name}: ${campus.address}. ${campus.contactInfo}. ${campus.descriptionHighlights}`,
                );
                this.logger.log(`‚úÖ Found campus: ${campus.name}`);
                break;
              }
            }
          }
        }
      }

      // T√¨m ki·∫øm th√¥ng tin ng√†nh h·ªçc - C·∫¢I THI·ªÜN LOGIC
      if (
        lowerQuestion.includes('ng√†nh') ||
        lowerQuestion.includes('major') ||
        lowerQuestion.includes('chuy√™n ng√†nh') ||
        lowerQuestion.includes('k·ªπ thu·∫≠t') ||
        lowerQuestion.includes('h·ªçc')
      ) {
        this.logger.log('üéì Searching for major information...');

        // Debug: Check data availability first
        const stats = await this.mongoDbDataService.getDataStatistics();
        this.logger.log('üìä MongoDB stats for major search:', stats);

        if (stats.majors === 0) {
          this.logger.log('‚ùå No majors found in MongoDB!');
        }

        // M·ªü r·ªông t·ª´ kh√≥a t√¨m ki·∫øm ng√†nh h·ªçc
        const majorKeywords = [
          // M√£ ng√†nh
          'se',
          'ai',
          'is',
          'ia',
          'ds',
          'iot',
          'gd',
          'mc',
          'mkt',
          'bf',
          'ba',
          'hrm',
          'act',
          'em',
          'hm',
          'el',
          // T√™n ti·∫øng Vi·ªát
          'ph·∫ßn m·ªÅm',
          'k·ªπ thu·∫≠t ph·∫ßn m·ªÅm',
          'software engineering',
          'tr√≠ tu·ªá',
          'tr√≠ tu·ªá nh√¢n t·∫°o',
          'artificial intelligence',
          'h·ªá th·ªëng th√¥ng tin',
          'information system',
          'an to√†n',
          'an to√†n th√¥ng tin',
          'information assurance',
          'cybersecurity',
          'd·ªØ li·ªáu',
          'khoa h·ªçc d·ªØ li·ªáu',
          'data science',
          'iot',
          'internet v·∫°n v·∫≠t',
          'internet of things',
          'ƒë·ªì h·ªça',
          'thi·∫øt k·∫ø ƒë·ªì h·ªça',
          'graphic design',
          'ƒëa ph∆∞∆°ng ti·ªán',
          'multimedia',
          'marketing',
          'digital marketing',
          't√†i ch√≠nh',
          'ng√¢n h√†ng',
          'banking finance',
          'qu·∫£n tr·ªã',
          'qu·∫£n tr·ªã kinh doanh',
          'business administration',
          'nh√¢n l·ª±c',
          'qu·∫£n tr·ªã nh√¢n l·ª±c',
          'human resources',
          'k·∫ø to√°n',
          'accounting',
          's·ª± ki·ªán',
          'qu·∫£n l√Ω s·ª± ki·ªán',
          'event management',
          'kh√°ch s·∫°n',
          'qu·∫£n tr·ªã kh√°ch s·∫°n',
          'hotel management',
          'ti·∫øng anh',
          'ng√¥n ng·ªØ anh',
          'english',
        ];

        for (const keyword of majorKeywords) {
          if (lowerQuestion.includes(keyword)) {
            this.logger.log(`üîç Found keyword: "${keyword}"`);
            const major =
              await this.mongoDbDataService.getMajorByCodeOrName(keyword);
            if (major) {
              contextParts.push(
                `Ng√†nh ${major.name} (${major.code}): ${major.description}. C∆° h·ªôi ngh·ªÅ nghi·ªáp: ${major.careerOpportunities}. T·ªïng t√≠n ch·ªâ: ${major.totalCredits}. Th·ªùi gian: ${major.programDuration}`,
              );
              this.logger.log(`‚úÖ Found major: ${major.name} (${major.code})`);
              break;
            }
          }
        }

        // N·∫øu kh√¥ng t√¨m th·∫•y ng√†nh c·ª• th·ªÉ, th·ª≠ t√¨m t·∫•t c·∫£ ng√†nh
        if (contextParts.length === 0) {
          this.logger.log('üîÑ No specific major found, getting all majors...');
          const stats = await this.mongoDbDataService.getDataStatistics();
          if (stats.majors > 0) {
            // L·∫•y m·ªôt v√†i ng√†nh ph·ªï bi·∫øn ƒë·ªÉ gi·ªõi thi·ªáu
            const seMajor =
              await this.mongoDbDataService.getMajorByCodeOrName('SE');
            const aiMajor =
              await this.mongoDbDataService.getMajorByCodeOrName('AI');

            const majorInfo = [];
            if (seMajor) majorInfo.push(`${seMajor.name} (${seMajor.code})`);
            if (aiMajor) majorInfo.push(`${aiMajor.name} (${aiMajor.code})`);

            if (majorInfo.length > 0) {
              contextParts.push(
                `FPT University c√≥ c√°c ng√†nh ƒë√†o t·∫°o ch√≠nh: ${majorInfo.join(', ')} v√† nhi·ªÅu ng√†nh kh√°c. T·ªïng c·ªông ${stats.majors} ng√†nh ƒë√†o t·∫°o.`,
              );
              this.logger.log(
                `‚úÖ Found general major info: ${stats.majors} majors`,
              );
            }
          }
        }
      }

      // T√¨m ki·∫øm h·ªçc ph√≠
      if (
        lowerQuestion.includes('h·ªçc ph√≠') ||
        lowerQuestion.includes('chi ph√≠') ||
        lowerQuestion.includes('tuition') ||
        lowerQuestion.includes('gi√°') ||
        lowerQuestion.includes('ti·ªÅn')
      ) {
        this.logger.log('üí∞ Searching for tuition information...');
        const majorKeywords = [
          'se',
          'ai',
          'is',
          'ia',
          'ds',
          'iot',
          'ph·∫ßn m·ªÅm',
          'tr√≠ tu·ªá',
          'an to√†n',
        ];
        for (const keyword of majorKeywords) {
          if (lowerQuestion.includes(keyword)) {
            const tuitionFees =
              await this.mongoDbDataService.getTuitionFeeByMajorCode(
                keyword.toUpperCase(),
              );
            if (tuitionFees && tuitionFees.length > 0) {
              const fee = tuitionFees[0];
              const majorInfo = fee.major as any;
              contextParts.push(
                `H·ªçc ph√≠ ng√†nh ${majorInfo?.name}: ${fee.baseAmount.toLocaleString('vi-VN')} ${fee.currency} cho ${fee.semesterRange}. Hi·ªáu l·ª±c t·ª´: ${fee.effectiveFrom?.toLocaleDateString('vi-VN')}`,
              );
              this.logger.log(`‚úÖ Found tuition for: ${majorInfo?.name}`);
              break;
            }
          }
        }
      }

      // T√¨m ki·∫øm h·ªçc b·ªïng
      if (
        lowerQuestion.includes('h·ªçc b·ªïng') ||
        lowerQuestion.includes('scholarship') ||
        lowerQuestion.includes('h·ªó tr·ª£') ||
        lowerQuestion.includes('mi·ªÖn gi·∫£m')
      ) {
        this.logger.log('üèÜ Searching for scholarship information...');
        const scholarships =
          await this.mongoDbDataService.getActiveScholarships();
        if (scholarships && scholarships.length > 0) {
          const topScholarships = scholarships.slice(0, 3);
          contextParts.push(
            `H·ªçc b·ªïng hi·ªán c√≥: ${topScholarships.map((s) => `${s.name} (${s.coverage}${s.value ? ` - ${s.value.toLocaleString('vi-VN')} VND` : ''})`).join(', ')}. T·ªïng c·ªông ${scholarships.length} ch∆∞∆°ng tr√¨nh h·ªçc b·ªïng.`,
          );
          this.logger.log(`‚úÖ Found ${scholarships.length} scholarships`);
        }
      }

      const result = contextParts.length > 0 ? contextParts.join('\n\n') : null;
      this.logger.log(
        `üìÑ MongoDB context result: ${result ? 'Found' : 'Not found'}`,
      );

      return result;
    } catch (error) {
      this.logger.error('‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu MongoDB realtime:', error);
      return null;
    }
  }

  /**
   * Tr·∫£ l·ªùi fallback d·ª±a tr√™n t·ª´ kh√≥a khi c·∫£ RAG v√† MongoDB ƒë·ªÅu kh√¥ng ho·∫°t ƒë·ªông
   * @param question C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns C√¢u tr·∫£ l·ªùi fallback
   */
  private getFallbackAnswer(question: string): string {
    const lowerQuestion = question.toLowerCase();

    this.logger.log(`üîÑ Using fallback answer for: "${lowerQuestion}"`);

    // Fallback cho c√°c ng√†nh h·ªçc c·ª• th·ªÉ
    if (
      lowerQuestion.includes('ng√†nh') ||
      lowerQuestion.includes('k·ªπ thu·∫≠t') ||
      lowerQuestion.includes('ph·∫ßn m·ªÅm') ||
      lowerQuestion.includes('major') ||
      lowerQuestion.includes('software') ||
      lowerQuestion.includes('ai') ||
      lowerQuestion.includes('tr√≠ tu·ªá') ||
      lowerQuestion.includes('an to√†n') ||
      lowerQuestion.includes('d·ªØ li·ªáu')
    ) {
      let response = `üéì **Th√¥ng tin c√°c ng√†nh ƒë√†o t·∫°o t·∫°i FPT University (Fallback):**\n\n`;

      if (
        lowerQuestion.includes('ph·∫ßn m·ªÅm') ||
        lowerQuestion.includes('software') ||
        lowerQuestion.includes('se')
      ) {
        response += `**üîß K·ªπ thu·∫≠t ph·∫ßn m·ªÅm (SE):**
- ƒê√†o t·∫°o k·ªπ s∆∞ ph·∫ßn m·ªÅm chuy√™n nghi·ªáp
- K·ªπ nƒÉng: L·∫≠p tr√¨nh, thi·∫øt k·∫ø h·ªá th·ªëng, qu·∫£n l√Ω d·ª± √°n
- C∆° h·ªôi ngh·ªÅ nghi·ªáp: Developer, Team Leader, Solution Architect
- Th·ªùi gian: 4 nƒÉm, 144 t√≠n ch·ªâ
- H·ªçc ph√≠: ~20.500.000 VND/h·ªçc k·ª≥\n\n`;
      }

      if (lowerQuestion.includes('ai') || lowerQuestion.includes('tr√≠ tu·ªá')) {
        response += `**ü§ñ Tr√≠ tu·ªá nh√¢n t·∫°o (AI):**
- Ch∆∞∆°ng tr√¨nh ti√™n ti·∫øn v·ªÅ AI, Machine Learning, Deep Learning
- K·ªπ nƒÉng: Computer Vision, NLP, Data Science
- C∆° h·ªôi ngh·ªÅ nghi·ªáp: AI Engineer, Data Scientist, ML Engineer
- Th·ªùi gian: 4 nƒÉm, 144 t√≠n ch·ªâ
- H·ªçc ph√≠: ~21.500.000 VND/h·ªçc k·ª≥\n\n`;
      }

      if (
        lowerQuestion.includes('an to√†n') ||
        lowerQuestion.includes('security')
      ) {
        response += `**üîí An to√†n th√¥ng tin (IA):**
- Chuy√™n ng√†nh v·ªÅ b·∫£o m·∫≠t m·∫°ng, an to√†n h·ªá th·ªëng
- K·ªπ nƒÉng: Penetration Testing, Forensics, Risk Management
- C∆° h·ªôi ngh·ªÅ nghi·ªáp: Security Engineer, CISO, Analyst
- Th·ªùi gian: 4 nƒÉm, 144 t√≠n ch·ªâ
- H·ªçc ph√≠: ~20.500.000 VND/h·ªçc k·ª≥\n\n`;
      }

      response += `üìû **Li√™n h·ªá ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt:**
- Hotline: (024) 7300 1866
- Email: daihocfpt@fpt.edu.vn
- Website: fpt.edu.vn

‚ö†Ô∏è *Th√¥ng tin n√†y l√† d·ª± ph√≤ng. ƒê·ªÉ c√≥ th√¥ng tin ch√≠nh x√°c v√† c·∫≠p nh·∫≠t nh·∫•t, vui l√≤ng li√™n h·ªá tr·ª±c ti·∫øp.*`;

      return response;
    }

    if (
      lowerQuestion.includes('h·ªçc ph√≠') ||
      lowerQuestion.includes('chi ph√≠')
    ) {
      return `üìö **Th√¥ng tin h·ªçc ph√≠ FPT University (Fallback):**

**K·ªπ thu·∫≠t ph·∫ßn m·ªÅm (SE):** 20.500.000 VND/h·ªçc k·ª≥
**Tr√≠ tu·ªá nh√¢n t·∫°o (AI):** 21.500.000 VND/h·ªçc k·ª≥
**An to√†n th√¥ng tin (IS):** 20.500.000 VND/h·ªçc k·ª≥
**Qu·∫£n tr·ªã kinh doanh (BA):** 19.500.000 VND/h·ªçc k·ª≥

*H·ªçc ph√≠ ƒë∆∞·ª£c t√≠nh theo t√≠n ch·ªâ v√† c√≥ th·ªÉ thay ƒë·ªïi theo t·ª´ng nƒÉm h·ªçc.*

üìû Li√™n h·ªá: (024) 7300 1866 ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.

‚ö†Ô∏è *Th√¥ng tin n√†y l√† d·ª± ph√≤ng. ƒê·ªÉ c√≥ th√¥ng tin ch√≠nh x√°c nh·∫•t, vui l√≤ng li√™n h·ªá tr·ª±c ti·∫øp.*`;
    }

    if (
      lowerQuestion.includes('campus') ||
      lowerQuestion.includes('c∆° s·ªü') ||
      lowerQuestion.includes('ƒë·ªãa ch·ªâ')
    ) {
      return `üè´ **C√°c campus c·ªßa FPT University (Fallback):**

**üåü H√† N·ªôi (Campus ch√≠nh)**
üìç Khu C√¥ng ngh·ªá cao H√≤a L·∫°c, Km29 ƒê·∫°i l·ªô ThƒÉng Long, Th·∫°ch Th·∫•t, H√† N·ªôi
üìû (024) 7300 1866

**üåü H·ªì Ch√≠ Minh**
üìç L√¥ E2a-7, ƒê∆∞·ªùng D1, Khu C√¥ng ngh·ªá cao, TP. Th·ªß ƒê·ª©c
üìû (028) 7300 1866

**üåü ƒê√† N·∫µng**
üìç Khu ƒë√¥ th·ªã c√¥ng ngh·ªá FPT ƒê√† N·∫µng, P. H√≤a H·∫£i, Q. Ng≈© H√†nh S∆°n
üìû (0236) 7300 999

‚ö†Ô∏è *Th√¥ng tin n√†y l√† d·ª± ph√≤ng. ƒê·ªÉ c√≥ th√¥ng tin ch√≠nh x√°c nh·∫•t, vui l√≤ng li√™n h·ªá tr·ª±c ti·∫øp.*`;
    }

    if (
      lowerQuestion.includes('xin ch√†o') ||
      lowerQuestion.includes('hello') ||
      lowerQuestion.includes('hi')
    ) {
      return `Xin ch√†o! üëã T√¥i l√† AI chatbot t∆∞ v·∫•n ngh·ªÅ nghi·ªáp c·ªßa FPT University.

üîÑ **H·ªá th·ªëng ƒëang ho·∫°t ƒë·ªông v·ªõi:**
- üéØ RAG (Retrieval-Augmented Generation) v·ªõi Pinecone + Gemini AI
- üóÑÔ∏è MongoDB real-time data integration
- üìä JSON file backup data
- üîß Fallback responses

T√¥i c√≥ th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ:
üéì C√°c ng√†nh ƒë√†o t·∫°o
üí∞ H·ªçc ph√≠
üèÜ H·ªçc b·ªïng
üè´ Th√¥ng tin campus
üìû Th√¥ng tin li√™n h·ªá

H√£y ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n! üòä`;
    }

    // C√¢u tr·∫£ l·ªùi m·∫∑c ƒë·ªãnh
    return `Xin l·ªói, hi·ªán t·∫°i t√¥i ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t v·ªõi c·∫£ h·ªá th·ªëng vector database v√† MongoDB.

**üîß C√°c h·ªá th·ªëng ƒëang g·∫∑p v·∫•n ƒë·ªÅ:**
- Vector Search (Pinecone + Gemini)
- MongoDB Real-time Data
- Backup JSON Data

B·∫°n c√≥ th·ªÉ li√™n h·ªá tr·ª±c ti·∫øp:
üìû Hotline: (024) 7300 1866
üìß Email: daihocfpt@fpt.edu.vn
üåê Website: fpt.edu.vn

Ho·∫∑c th·ª≠ ƒë·∫∑t c√¢u h·ªèi l·∫°i sau v√†i ph√∫t.`;
  }
}
